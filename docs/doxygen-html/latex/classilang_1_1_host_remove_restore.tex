\hypertarget{classilang_1_1_host_remove_restore}{}\section{ilang\+:\+:Host\+Remove\+Restore Class Reference}
\label{classilang_1_1_host_remove_restore}\index{ilang\+::\+Host\+Remove\+Restore@{ilang\+::\+Host\+Remove\+Restore}}


Class to remove and restore the host info This is useful as we want the ast with the same name generates the same z3 expr. This framework is based on an assumption that if we call z3 to create the variable of the same name multiple times they refer to the same one internally. F\+I\+X\+ME\+: Need to check this assumption if we want to support other S\+MT solvers!  




{\ttfamily \#include $<$inter\+\_\+ila\+\_\+unroller.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_af0c048ec7148a9b3fa8bbfa84bb8727e}\label{classilang_1_1_host_remove_restore_af0c048ec7148a9b3fa8bbfa84bb8727e}} 
typedef std\+::map$<$ \mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}}, \mbox{\hyperlink{namespaceilang_ad1b30fdf347e493b3937143da05d1a72}{Instr\+Lvl\+Abs\+Ptr}} $>$ \mbox{\hyperlink{classilang_1_1_host_remove_restore_af0c048ec7148a9b3fa8bbfa84bb8727e}{Expr\+Host\+Map}}
\begin{DoxyCompactList}\small\item\em type of the internal map \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_ad6fe1a90d3e53376a4a4564bb36a4eb5}\label{classilang_1_1_host_remove_restore_ad6fe1a90d3e53376a4a4564bb36a4eb5}} 
typedef std\+::function$<$ bool(const \mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}} \&)$>$ \mbox{\hyperlink{classilang_1_1_host_remove_restore_ad6fe1a90d3e53376a4a4564bb36a4eb5}{Expr\+Judge\+Func}}
\begin{DoxyCompactList}\small\item\em type of function object from to decide if we should remove the host of a expr or not \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_a31be62debd3a138eb7dea4e0bea5692f}\label{classilang_1_1_host_remove_restore_a31be62debd3a138eb7dea4e0bea5692f}} 
\mbox{\hyperlink{classilang_1_1_host_remove_restore_a31be62debd3a138eb7dea4e0bea5692f}{Host\+Remove\+Restore}} ()
\begin{DoxyCompactList}\small\item\em Default constructor\+: do nothing. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_a77e6d0983f1fba71a90d8f5ed0dabce6}\label{classilang_1_1_host_remove_restore_a77e6d0983f1fba71a90d8f5ed0dabce6}} 
\mbox{\hyperlink{classilang_1_1_host_remove_restore_a77e6d0983f1fba71a90d8f5ed0dabce6}{$\sim$\+Host\+Remove\+Restore}} ()
\begin{DoxyCompactList}\small\item\em Default destructor\+: do nothing. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_af382d6d3dde828ecc1df556af1519644}\label{classilang_1_1_host_remove_restore_af382d6d3dde828ecc1df556af1519644}} 
void \mbox{\hyperlink{classilang_1_1_host_remove_restore_af382d6d3dde828ecc1df556af1519644}{Record\+And\+Remove}} (\mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}} exp)
\begin{DoxyCompactList}\small\item\em record the host field and remove them \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_aab043ec92a30fc001e9f86c97d9dc2de}\label{classilang_1_1_host_remove_restore_aab043ec92a30fc001e9f86c97d9dc2de}} 
void \mbox{\hyperlink{classilang_1_1_host_remove_restore_aab043ec92a30fc001e9f86c97d9dc2de}{Record\+And\+Remove\+If}} (\mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}} exp, \mbox{\hyperlink{classilang_1_1_host_remove_restore_ad6fe1a90d3e53376a4a4564bb36a4eb5}{Expr\+Judge\+Func}} f)
\begin{DoxyCompactList}\small\item\em record the host field and remove them if allowed by the second argument This only provides more constraints in additional to Record\+And\+Remove (var type, not recorded or compatible with old records) This is useful as we only need to replace the host() of shared variables \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_a158245e0c24fa8bb875e06e968d04bfa}\label{classilang_1_1_host_remove_restore_a158245e0c24fa8bb875e06e968d04bfa}} 
void {\bfseries Record\+And\+Replace\+If} (\mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}} exp, \mbox{\hyperlink{classilang_1_1_host_remove_restore_ad6fe1a90d3e53376a4a4564bb36a4eb5}{Expr\+Judge\+Func}} f, \mbox{\hyperlink{namespaceilang_ad1b30fdf347e493b3937143da05d1a72}{Instr\+Lvl\+Abs\+Ptr}} h)
\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_a91a45a5e32fd89096d1425d5795b29a2}\label{classilang_1_1_host_remove_restore_a91a45a5e32fd89096d1425d5795b29a2}} 
void \mbox{\hyperlink{classilang_1_1_host_remove_restore_a91a45a5e32fd89096d1425d5795b29a2}{Restore}} (\mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}} exp)
\begin{DoxyCompactList}\small\item\em add back the host field according to the map \end{DoxyCompactList}\item 
\mbox{\Hypertarget{classilang_1_1_host_remove_restore_ae290c429c0d73072f09eb301f90dd7cc}\label{classilang_1_1_host_remove_restore_ae290c429c0d73072f09eb301f90dd7cc}} 
void \mbox{\hyperlink{classilang_1_1_host_remove_restore_ae290c429c0d73072f09eb301f90dd7cc}{Restore\+All}} (\mbox{\hyperlink{namespaceilang_ad1b30fdf347e493b3937143da05d1a72}{Instr\+Lvl\+Abs\+Ptr}} h=nullptr)
\begin{DoxyCompactList}\small\item\em restore all the expr recoreded \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Class to remove and restore the host info This is useful as we want the ast with the same name generates the same z3 expr. This framework is based on an assumption that if we call z3 to create the variable of the same name multiple times they refer to the same one internally. F\+I\+X\+ME\+: Need to check this assumption if we want to support other S\+MT solvers! 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{inter__ila__unroller_8h}{inter\+\_\+ila\+\_\+unroller.\+h}}\end{DoxyCompactItemize}
