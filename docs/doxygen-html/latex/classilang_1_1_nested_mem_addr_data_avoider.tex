\hypertarget{classilang_1_1_nested_mem_addr_data_avoider}{}\section{ilang\+:\+:Nested\+Mem\+Addr\+Data\+Avoider Class Reference}
\label{classilang_1_1_nested_mem_addr_data_avoider}\index{ilang\+::\+Nested\+Mem\+Addr\+Data\+Avoider@{ilang\+::\+Nested\+Mem\+Addr\+Data\+Avoider}}


Class of traversing to avoid nested memory access in address.  




{\ttfamily \#include $<$ast\+\_\+helper.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{classilang_1_1_nested_mem_addr_data_avoider_a4a3d3317a3ebfbc7c7958bff6333d6e9}{Not\+Nested}} (const \mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}} \&node)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Class of traversing to avoid nested memory access in address. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classilang_1_1_nested_mem_addr_data_avoider_a4a3d3317a3ebfbc7c7958bff6333d6e9}\label{classilang_1_1_nested_mem_addr_data_avoider_a4a3d3317a3ebfbc7c7958bff6333d6e9}} 
\index{ilang\+::\+Nested\+Mem\+Addr\+Data\+Avoider@{ilang\+::\+Nested\+Mem\+Addr\+Data\+Avoider}!Not\+Nested@{Not\+Nested}}
\index{Not\+Nested@{Not\+Nested}!ilang\+::\+Nested\+Mem\+Addr\+Data\+Avoider@{ilang\+::\+Nested\+Mem\+Addr\+Data\+Avoider}}
\subsubsection{\texorpdfstring{Not\+Nested()}{NotNested()}}
{\footnotesize\ttfamily bool ilang\+::\+Nested\+Mem\+Addr\+Data\+Avoider\+::\+Not\+Nested (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{namespaceilang_a7c4196c72e53ea4df4b7861af7bc3bce}{Expr\+Ptr}} \&}]{node }\end{DoxyParamCaption})}

To check for a mem var, if its ast does not contain nested mem address/data access In its nested check, it should check go into all types. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{ast__helper_8h}{ast\+\_\+helper.\+h}}\end{DoxyCompactItemize}
