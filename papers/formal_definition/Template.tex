%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 11 pt]{article}
\usepackage[utf8]{inputenc}     

\usepackage{url}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{proof}
\usepackage{tikz}
\usepackage[margin=1.2in]{geometry}

\title{Instruction-Level Abstraction Synthesis Template Definition}
\author{
    \begin{tabular}{ccccc}
    Hongce~Zhang & Pramod~Subramanyan & Bo-Yuan~Huang & Aarti~Gupta$^\dagger$ & Sharad~Malik \\
    \multicolumn{5}{c} {Departments of Computer Science$^\dagger$ and Electrical Engineering, Princeton University} \\
    \end{tabular}
}
\date{Draft Working Document: \today}

\usepackage{natbib}
\usepackage{graphicx}

\begin{document}

\providecommand{\bd}[0]{\mathbb{B}}
\providecommand{\st}[1]{\mathrm{#1}}
\providecommand{\ft}[1]{\mathtt{#1}}

\maketitle

\section{Template for Instructions}
Template provides human insights for abstraction. 

%arch states
A template should specify module input $W$ and the architecture states $S$ including both registers and memories. These states should be visible from the port. The visibility here can be direct, meaning its value is accessible from the outside, or indirect, where some directly visible states are updated according to its value. 

Fetch function $F$ inside the template specifies what an abstract instruction makes of. It is a function that maps states and inputs to a bitvector (or the instruction). The fetch valid function $V$ indicates the condition when there is truly instruction for the module. It is designed to help model accelerators which do not always have an instruction to execute.

Each instruction is associated with a decode function. Given the bitvector generated by fetching, it distinguishes among different instructions.

Unlike ILA, the template does not have a set of state update functions, but a unified one which maps the current vector of states and inputs to the vector of future values.
 
The template is defined as, 

\begin{eqnarray}
  \mathrm{T} &=& \langle S, W, F, V, D, P, T\rangle \text{, where} \nonumber \\
      &S& \text{ is the vector of state variables, } \nonumber \\
      &W& \text{ is the vector of input variables, } \nonumber \\
      &V& :(S\times W) \mapsto \bd \text{ is the valid function, } \nonumber \\
      &F& :(S\times W) \mapsto bvec_w \text{ is the fetch function,} \nonumber \\
      &D& = \{ \delta_i : bvec_w \mapsto \bd \} 
            \text{ is the set of decode functions,} \nonumber \\
      &P& = \{ p_j \} \text{ is the set of parameters, } \nonumber \\
			& &\text{whose values depend solely on the assignment of $D$, and } \nonumber \\
      &N& = (S \times W \times P) \mapsto S 
            \text{ is the template of next state functions.} \nonumber
\end{eqnarray}

%
	  %&U& = \{ f_k : (bvec\times bvec\times ...) \mapsto bvec \} \text{ is the set of uninterpreted functions, and} \nonumber \\

The parameters $\{ p_j \}$ here are the ``holes'' we allow in the our template. They appear in the form of unknown constants within a range, undetermined choices, slicing certain bits from a bitvector and so on. The value of these parameters should be a function of an assignment to the set $D$ of decode functions. In other word, the unknown constant, the choice, etc. should be completed fixed for a given kind of instructions.

\section{Template for Child-Instructions}



%\bibliographystyle{plain}
%\bibliography{references}
\end{document}

