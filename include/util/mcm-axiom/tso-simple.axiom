InstructionSet WRITE {
    ila-write %shared  # or a state name
} with-facet-event wfe.global {W: %all-shared}  # W means update, wfe.global is a label
# %all-shared or a name or %individual
# with-facet-event           or facet-events


InstructionSet READ {
    ila-read %shared
}  # so this won't create a facet event
# I tend to use the instruction event 
# instead of declare 

InstructionSet FENCE {
    ila-name fence \/
    ila-name Fence \/
    ila-name FENCE 
}  # this means no facet events

InstructionSet RMW {
    ila-name atomic_add \/
    ila-name atomic_and # \/ ... possibly more
} 
# this will not create more facet events
# but the above READ/WRITE already create events
# so the purpose of this set is just create a name
# so we can refer to it later

# InstructionSet PureWrite =
# { WRITE-RMW }
# 
# # operator-allowed: | & - ^ ()

Axiom RF_CO_FR
forall r:READ | exists w:WRITE (~=r) |
    SameAddress[w,r] /\ SameData[w,r] /\ Decode[w] /\
    RF[w,r] /\ ( forall w2:WRITE (~= w)  | 
        ( SameAddress[w,w2] /\ Decode[w2] ) => 
            CO[w2,w] \/ FR[r,w2] )

# SameAddress contains two meanings actually
# Same state name, and if it is a memory state
# The addresses are the same

Axiom TSO_WriteFacetOrder
forall w: ( WRITE - RMW ) | HB[ w , w.wfe.global ] /\ 
    
Axiom TSO_Store
forall w1:WRITE | forall w2 : WRITE (~=w1) | 
    PO [ w1, w2 ] => HB[ w1.wfe.global, w2.wfe.global] /\ 

Axiom TSO_Fence
forall f:FENCE | forall w: WRITE | PO[w,f] => 
    HB [ w.wfe.global, f]

Axiom TSO_RMW
forall i:RMW | 
    Sync[i, i.wfe.global ] 

Define RF[w,r] := 
     SameCore[w,r] => HB[w , r] /\
    ~SameCore[w,r] => HB[w.wfe.global, r]

Define FR[r,w] := 
     SameCore[r,w] => HB[r , w] /\
    ~SameCore[r,w] => HB[r , w.wfe.global]

Define CO[w1,w2] :=
     SameCore[w1,w2] => HB[ w1, w2 ] /\
    ~SameCore[w1,w2] => HB[ w1.wfe.global, w2.wfe.global ]

